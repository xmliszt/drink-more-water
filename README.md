# Drink Water ðŸ˜ŠðŸ’¦

## Overview

**Drink Water** is a simple web application that helps you keep track of daily water intake and have a fun UI for users to compete against each other. User sets his or her own goal and capacity of the water cup used, and log the water intake for the day. Once achieved the goal, the user will be granted with **1 point** which will be added towards his or her total score. A scoreboard can be viewed to see who has collected the most points.

## Project setup

### Frontend

**Drink Water**'s frontend is written in **VueJS**. A docker container can be setup from the `Dockerfile` to run it with ease. `./run.sh` script is written for easily spin up a docker container.

### Backend

**Drink Water**'s backend is written in **NodeJS**. A docker container can be setup from the `Dockerfile` to run it with ease. `./run.sh` script is written for easily spin up a docker container.

The database used is **Sqlite3** which is a lightweight database. A fresh new database will be spawned when a new Docker container is set up and running.

## Project Setup

### Overview

The project can be set up on a fresh EC2 instance running Ubuntu. A setup script is provided in root `./setup.sh`. There are several pre-requisites for the project to be successfully set up.

**Nginx** is needed to act as a reverse proxy to communicate with the client and the server running on local.

The current project has SSL certificate setup with CA certificate signed by **Certbot**. The domain is configured via AWS Route R3

### Pre-requisites

**Docker**

Ubuntu docker installation can be found [here](https://docs.docker.com/engine/install/ubuntu/)

```bash
sudo apt-get update
sudo apt-get install \
    ca-certificates \
    curl \
    gnupg \
    lsb-release
sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
```

**Node**
You need `nodejs` for running the project

```bash
sudo apt update
sudo apt install nodejs
sudo apt install npm
```

You can also use Node Version Manager to install. The following example install v14.10.0 node

```bash
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh
nvm install v14.10.0
```

**Certbot (for HTTPS setup)**

```
sudo snap install core; sudo snap refresh core
sudo snap install --classic certbot
```

### Setup project

Once you have all the pre-requisites, we can spin up the container using the `setup.sh` script at root.

```
sudo ./setup.sh
```

After this, you should have two Docker containers running. One is the **client frontend**, the other is the **server backend**. To view the running containers:

```
sudo docker ps
```

### Setup Nginx reverse proxy

We now need to set up Nginx reverse proxy to serve our web application via HTTPS. First step is to use **Certbot** to generate the CA certificate.

```
sudo certbot --nginx
```

This will prompt you for information about your domain. Once successful, it will auto store the CA certs and refer them in your Nginx configuration file `/etc/nginx/sites-available/default`

Here is a sample configuration file, the variables are replaced by `$<xxx>` for you to replace with your own configuration.

```
server {
        listen [::]:443 ssl ipv6only=on; # managed by Certbot
        listen 443 ssl; # managed by Certbot
        ssl_certificate $<SSL Certificate generated by Certbot>; # managed by Certbot
        ssl_certificate_key $<SSL Certificate key generated by Certbot>; # managed by Certbot
        include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
        ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot

        root /var/www/html;
        index index.html index.htm index.nginx-debian.html;
        server_name $<Your domain>; # managed by Certbot

        location / {
                proxy_pass http://localhost:8080;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header Host $host;
        }

        location /api {
                proxy_pass http://localhost:3000;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header Host $host;
                proxy_redirect off;
        }

        location ~ /\.ht {
                deny all;
        }
}

server {
    if ($host = $<Your domain>) {
        return 301 https://$host;
    } # managed by Certbot

    listen 80 ;
    listen [::]:80 ;
    server_name $<Your domain>;
    return 301 https://$<Your domain>; # managed by Certbot
}
```

After setup, your website should be publicly accessible via: `https://$<Your domain>`
